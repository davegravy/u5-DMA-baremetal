/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <main.h>

/*
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/

#include <stm32u5xx.h>

#define Size 16383

uint8_t RxBuffer[Size*4];
uint8_t RxBytesRemaining;

void system_clk_init()
{

	//set flash prefetch
	SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);

	//enable PWR CLK
	SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_PWREN);

	//Set power scaling (for high clock)
	MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), ((PWR_VOSR_VOS_0 | PWR_VOSR_VOS_1) | PWR_VOSR_BOOSTEN));

	//disable PWR CLK
	CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_PWREN);

	//enable MSI
	SET_BIT(RCC->CR, RCC_CR_MSISON);
	while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U){
	}

	//Set MSI range and calibration
	SET_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL);
	MODIFY_REG(RCC->ICSCR1, RCC_ICSCR1_MSISRANGE, (RCC_ICSCR1_MSISRANGE_2));
	MODIFY_REG((RCC->ICSCR2), (RCC_ICSCR2_MSITRIM1), ((uint32_t)(0x10U)<<\
	                                                        RCC_ICSCR2_MSITRIM1_Pos));
	//set flash latency
	//MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (FLASH_ACR_LATENCY_0WS));
	MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (FLASH_ACR_LATENCY_4WS));

	//SysTick stuff skipped

	//disable PLL1
	CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
	while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
	{
	}

	//
	// PLL
	//

	//enable PWR CLK
	SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_PWREN);

	CLEAR_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
	MODIFY_REG(RCC->PLL1CFGR,(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1M|\
	                                  RCC_PLL1CFGR_PLL1MBOOST), ((RCC_PLL1CFGR_PLL1SRC_0) << RCC_PLL1CFGR_PLL1SRC_Pos) |\
	                   (((1) - 1U) << RCC_PLL1CFGR_PLL1M_Pos) | (0x00000000U));

	MODIFY_REG(RCC->PLL1DIVR ,(RCC_PLL1DIVR_PLL1N | RCC_PLL1DIVR_PLL1P | RCC_PLL1DIVR_PLL1Q |\
	                               RCC_PLL1DIVR_PLL1R), ( (((80) - 1U ) & RCC_PLL1DIVR_PLL1N) |\
	                                                      ((((2) -1U ) << RCC_PLL1DIVR_PLL1P_Pos) & \
	                                                       RCC_PLL1DIVR_PLL1P) | \
	                                                      ((((2) -1U) << RCC_PLL1DIVR_PLL1Q_Pos) & \
	                                                       RCC_PLL1DIVR_PLL1Q) |\
	                                                      ((((2)- 1U) << RCC_PLL1DIVR_PLL1R_Pos) & \
	                                                       RCC_PLL1DIVR_PLL1R)));
	//Disable PLL1 fractional divider
	CLEAR_BIT(RCC->PLL1CFGR, RCC_PLL1CFGR_PLL1FRACEN);

	//change PLL1 fractional divider
	MODIFY_REG(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN,\
	                                                    (uint32_t)(0) << \
	                                                    RCC_PLL1FRACR_PLL1FRACN_Pos);
	//Enable PLL1 fractional divider
	SET_BIT(RCC->PLL1CFGR, RCC_PLL1CFGR_PLL1FRACEN);

	//Select reference frequency range VCI
	MODIFY_REG(RCC->PLL1CFGR, RCC_PLL1CFGR_PLL1RGE, (0x00000000U));

	/* Enable the EPOD to reach max frequency */
	SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);

	//Disable PWR CLK
	CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_PWREN);

	//Enable PLL1 system clock output
	SET_BIT(RCC->PLL1CFGR, (RCC_PLL1CFGR_PLL1REN));

	//Enable PLL1
	SET_BIT(RCC->CR, RCC_CR_PLL1ON);

	while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
	{}


	//
	//Peripheral Clocks
	//

	//enable PWR CLK
	SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_PWREN);

	if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) != 0U)
	      {
			while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
				{}
	      }

	//disable PWR CLK
	CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_PWREN);

	//wait for PLL ready
	while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
	{}

	//Set SysCLK source
	MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, (RCC_CFGR1_SW_0 | RCC_CFGR1_SW_1));

	//Wait until source is confirmed updated
	while (((uint32_t)(RCC->CFGR1 & RCC_CFGR1_SWS)) != (RCC_CFGR1_SWS_0 | RCC_CFGR1_SWS_1))
	      {}

	//Set AHBCLK Divider
	MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, 0x00000000U);

	//Set APB1CLK Divider
	MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (0x00000000U));

	//Set APB2CLK Divider
	MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (((0x00000000U)) << 4));

	//Set APB3CLK Divider
    MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, (0x00000000U));

}

typedef enum
{
    GPIO_MODER_INPUT = 0b00,
    GPIO_MODER_OUTPUT = 0b01,
    GPIO_MODER_ALTERNATE = 0b10,
    GPIO_MODER_ANALOG   = 0b11,
}GPIO_MODER;

void GPIO_SetMODER(GPIO_TypeDef *gpio, int pin, GPIO_MODER mode)
{
    uint32_t reg = gpio -> MODER;

    reg &= ~(0b11 << (pin * 2));
    reg |= (mode & 0b11) << (pin * 2);

    gpio -> MODER = reg;
}

typedef enum
{
	GPIO_OSPEEDR_LOW = 0b00,
	GPIO_OSPEEDR_MEDIUM = 0b01,
	GPIO_OSPEEDR_HIGH = 0b10,
	GPIO_OSPEEDR_VERY_HIGH = 0b11,
}GPIO_OSPEEDR;

void GPIO_SetOSPEEDR(GPIO_TypeDef *gpio, int pin, GPIO_OSPEEDR ospeed)
{
    uint32_t reg = gpio -> OSPEEDR;

    reg &= ~(0b11 << (pin * 2));
    reg |= (ospeed & 0b11) << (pin * 2);

    gpio -> OSPEEDR = reg;
}

void GPIO_init() {

	//Enable GPIOx clocks
		SET_BIT(RCC->AHB2ENR1, RCC_AHB2ENR1_GPIOAEN);
		SET_BIT(RCC->AHB2ENR1, RCC_AHB2ENR1_GPIOBEN);
		SET_BIT(RCC->AHB2ENR1, RCC_AHB2ENR1_GPIOCEN);
		SET_BIT(RCC->AHB2ENR1, RCC_AHB2ENR1_GPIOEEN);


		GPIO_SetMODER(GPIOA, 5, GPIO_MODER_ALTERNATE); //SPI1_SCK
		GPIO_SetOSPEEDR(GPIOA, 5, GPIO_OSPEEDR_VERY_HIGH);
		MODIFY_REG(GPIOA->PUPDR, (0b11) << 5U * 2, (0b00) << 5U * 2 ); // set no-pull-down
		MODIFY_REG(GPIOA->AFR[0], 0b111 << 5*4, 0b0101 << 5*4);


		GPIO_SetMODER(GPIOA, 6, GPIO_MODER_ALTERNATE); //SPI1_MISO
		GPIO_SetOSPEEDR(GPIOA, 6, GPIO_OSPEEDR_VERY_HIGH);
		MODIFY_REG(GPIOA->AFR[0], 0b111 << 6*4, 0b0101 << 6*4);

		GPIO_SetMODER(GPIOA, 7, GPIO_MODER_ALTERNATE); //SPI1_MOSI
		GPIO_SetOSPEEDR(GPIOA, 7, GPIO_OSPEEDR_VERY_HIGH);


		GPIO_SetMODER(GPIOB, 2, GPIO_MODER_ALTERNATE); //SPI1_RDY
		GPIO_SetOSPEEDR(GPIOB, 2, GPIO_OSPEEDR_VERY_HIGH); //SPI1_RDY
		MODIFY_REG(GPIOB->AFR[0], 0b1111 << 2*4, 0b0101 << 2*4);

/*
		GPIO_SetMODER(GPIOA, 4, GPIO_MODER_INPUT); //DRL
		SET_BIT(EXTI->FTSR1, (0b1 << 4)); //falling edge trigger
		SET_BIT(EXTI->IMR1, (0b1 << 4)); //add interrupt mask
*/

		GPIO_SetMODER(GPIOA, 2, GPIO_MODER_OUTPUT); //SEL1
		GPIO_SetOSPEEDR(GPIOA, 2, GPIO_OSPEEDR_LOW);

		GPIO_SetMODER(GPIOA, 3, GPIO_MODER_OUTPUT); //SEL0
		GPIO_SetOSPEEDR(GPIOA, 3, GPIO_OSPEEDR_LOW);

		GPIO_SetMODER(GPIOB, 0, GPIO_MODER_OUTPUT); //RDLB
		GPIO_SetOSPEEDR(GPIOB, 0, GPIO_OSPEEDR_LOW);

		GPIO_SetMODER(GPIOC, 3, GPIO_MODER_OUTPUT); //RDLA
		GPIO_SetOSPEEDR(GPIOB, 3, GPIO_OSPEEDR_LOW);

		GPIO_SetMODER(GPIOE, 2, GPIO_MODER_ALTERNATE); //TIM3_ETR
		GPIO_SetOSPEEDR(GPIOE, 2, GPIO_OSPEEDR_VERY_HIGH);

		GPIO_SetMODER(GPIOE, 3, GPIO_MODER_ALTERNATE); //TIM3_CH1
		GPIO_SetOSPEEDR(GPIOE, 3, GPIO_OSPEEDR_VERY_HIGH);

		WRITE_REG(GPIOA->BSRR, (0b1 << 2) | (0b1 << 3) ); //SEL1, SEL0 high
		WRITE_REG(GPIOB->BSRR, (0b1 << 0)); //RDLB high
		WRITE_REG(GPIOC->BSRR, (0b0 << 3)); //RDLA low

		GPIO_SetMODER(GPIOA, 9, GPIO_MODER_ALTERNATE); //USUART TX
		GPIO_SetOSPEEDR(GPIOA, 9, GPIO_OSPEEDR_VERY_HIGH);
		MODIFY_REG(GPIOA->AFR[1], 0b1111 << 1*4, 0b0111 << 1*4);
		MODIFY_REG(GPIOA->PUPDR, (0b11) << 9U * 2, (0b10) << 9U * 2 ); // set pull-down

		GPIO_SetMODER(GPIOA, 10, GPIO_MODER_ALTERNATE); //USUART RX
		GPIO_SetOSPEEDR(GPIOA, 10, GPIO_OSPEEDR_VERY_HIGH);
		MODIFY_REG(GPIOA->AFR[1], 0b1111 << 2*4, 0b0111 << 2*4);
		MODIFY_REG(GPIOA->PUPDR, (0b11) << 10U * 2, (0b10) << 10U * 2 ); // set pull-down

}

void TIM3_init() {

	SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM3EN);

	MODIFY_REG(GPIOE->AFR[0], 0b1111 << 2*4, 0b0010 << 2*4);
	MODIFY_REG(GPIOE->AFR[0], 0b1111 << 3*4, 0b0010 << 3*4);

	WRITE_REG(TIM3->ARR, (uint32_t) 190U); //set period

	/* Generate an update event to reload the Prescaler
	     and the repetition counter (only for advanced timer) value immediately */
	WRITE_REG(TIM3->EGR, TIM_EGR_UG);

	WRITE_REG(TIM3->CR1, 0x8); //set one-pulse-mode
	WRITE_REG(TIM3->SMCR, 0x76); //set slave-mode trigger TIM3_ETR
	WRITE_REG(TIM3->CR2, 0x10); //not sure?
	WRITE_REG(TIM3->CCMR1, 0x78); //not sure?
	WRITE_REG(TIM3->CCR1, 50U); //set pulse

}

void NVIC_init() {
	  uint32_t prioritygroup;
	  prioritygroup = NVIC_GetPriorityGrouping();
	  NVIC_SetPriority(EXTI4_IRQn, NVIC_EncodePriority(prioritygroup, 0, 0));
}

void SPI_init() {

	//set SPI1 clock source
	MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SPI1SEL, (uint32_t)(RCC_CCIPR1_SPI1SEL_0));

	//enable SPI1 clock source
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);

	//Enable SPI1 interrupts
	uint32_t prioritygroup;
	prioritygroup = NVIC_GetPriorityGrouping();
    NVIC_SetPriority(SPI1_IRQn, NVIC_EncodePriority(prioritygroup, 0, 0));
    NVIC_EnableIRQ(SPI1_IRQn);

	//DISABLE SPI1 peripheral
	CLEAR_BIT(SPI1->CR1, SPI_CR1_SPE);

	SET_BIT(SPI1->CR1, SPI_CR1_SSI);

	//Configure SPI1 peripheral part 1
	WRITE_REG(SPI1->CFG1, (SPI_BAUDRATEPRESCALER_4 | 0x70000 | SPI_FIFO_THRESHOLD_03DATA | \
			SPI_DATASIZE_32BIT ));

	//AFCTR= 1 or 0?
	//Configure SPI1 peripheral part 2
	WRITE_REG(SPI1->CFG2, SPI_POLARITY_LOW | SPI_PHASE_1EDGE | \
			SPI_CFG2_MASTER | SPI_CFG2_COMM_1 | /*SPI_CFG2_COMM_Msk |*/ SPI_CFG2_SSM |\
			SPI_MASTER_INTERDATA_IDLENESS_15CYCLE | SPI_CFG2_RDIMM);

	//Configure autonomous mode
	//WRITE_REG(SPI1->AUTOCR, SPI_AUTOCR_TRIGEN | SPI_AUTOCR_TRIGPOL | SPI_AUTOCR_TRIGSEL_2);

	//WRITE_REG(SPI1->CFG2, 0x7460000);
	//WRITE_REG(SPI1->CFG2, 0x5440000);
	//SET_BIT(SPI1->IFCR, 0b1000000000);

}

void CRC_init() {

	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);
	WRITE_REG(CRC->CR, 0x10); //8bit CRC
	WRITE_REG(CRC->POL, 0x7); //polynomial
	WRITE_REG(CRC->INIT, 0x0); //initial value

}

void DMA_init(uint8_t *ptrRxBuffer) {

	//enable GPDMA clock
	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPDMA1EN);

	//Enable GPDMA ch6 interrupts
	uint32_t prioritygroup;
	prioritygroup = NVIC_GetPriorityGrouping();
    NVIC_SetPriority(GPDMA1_Channel6_IRQn, NVIC_EncodePriority(prioritygroup, 0, 0));
    NVIC_EnableIRQ(GPDMA1_Channel6_IRQn);

    //disable DMA channel
    GPDMA1_Channel6->CCR |= (DMA_CCR_SUSP | DMA_CCR_RESET);

    /* Check if the DMA channel is effectively disabled */
      while ((GPDMA1_Channel6->CCR & DMA_CCR_EN) != 0U)
      {}

    //CCR
    uint32_t CCRreg;
    CCRreg = DMA_CCR_PRIO_1 | DMA_LSM_FULL_EXECUTION | 0x20000; //DMA_CCR_LAP == 0x2000
    MODIFY_REG(GPDMA1_Channel6->CCR, (DMA_CCR_PRIO | 0x20000 | DMA_CCR_LSM), CCRreg); //DMA_CCR_LAP == 0x2000


    //set transfer event mode
    WRITE_REG(GPDMA1_Channel6->CTR2, DMA_CTR2_TCEM);

    WRITE_REG(GPDMA1_Channel6->CTR1, 0U);
    WRITE_REG(GPDMA1_Channel6->CBR1, 0U);
    WRITE_REG(GPDMA1_Channel6->CSAR, 0U);
    WRITE_REG(GPDMA1_Channel6->CDAR, 0U);
    WRITE_REG(GPDMA1_Channel6->CLLR, 0U);

#define DestBurstLength  1
#define SrcBurstLength  1

    uint32_t LinkRegisters[8U];
    uint32_t CTR1_DBL;
    uint32_t CTR1_SBL;

    //configure Link Registers
    CTR1_DBL = (DestBurstLength - 1U) << 20U & 0x3f00000;
    CTR1_SBL = (SrcBurstLength - 1U) << 4U & 0x3f0;

    LinkRegisters[NODE_CTR1_DEFAULT_OFFSET] = DMA_CTR1_DINC | DMA_DEST_DATAWIDTH_WORD |\
    		DMA_DATA_RIGHTALIGN_ZEROPADDED | DMA_SINC_FIXED | DMA_SRC_DATAWIDTH_WORD |\
			DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT0 | DMA_EXCHANGE_NONE |\
			CTR1_DBL | CTR1_SBL;
    LinkRegisters[NODE_CTR2_DEFAULT_OFFSET] = DMA_TCEM_BLOCK_TRANSFER | GPDMA1_REQUEST_SPI1_RX;
    LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = Size*4;
    LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] = (uint32_t)&SPI1->RXDR;
    LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] = (uint32_t)ptrRxBuffer;
    LinkRegisters[NODE_CTR3_DEFAULT_OFFSET] = 0;
	LinkRegisters[NODE_CBR2_DEFAULT_OFFSET] = 0;
	LinkRegisters[NODE_CLLR_2D_DEFAULT_OFFSET] = 0;

    SET_BIT(GPDMA1_Channel6->CCR, DMA_CCR_TCIE | DMA_CCR_HTIE | DMA_CCR_DTEIE |\
    		DMA_CCR_ULEIE | DMA_CCR_USEIE | DMA_CCR_TOIE);

    //point CLBAR and CLLR to Link Registers
    GPDMA1_Channel6->CLBAR = (uint32_t)LinkRegisters & DMA_CLBAR_LBA;
    GPDMA1_Channel6->CLLR = ((uint32_t)LinkRegisters & DMA_CLLR_LA) | DMA_CLLR_UT1 |\
    		DMA_CLLR_UT2 | DMA_CLLR_UB1 | DMA_CLLR_USA | DMA_CLLR_UDA | DMA_CLLR_ULL;

    SET_BIT(GPDMA1_Channel6->CCR, DMA_CCR_EN );

    SET_BIT(SPI1->CFG1, SPI_CFG1_RXDMAEN);

}

void USART_init(void){

	//set clock source
	MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_USART1SEL, 0U); // RCC_USART1CLKSOURCE_PCLK2

	//enable USART clock
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);

	//disable USUART
	CLEAR_BIT(USART1->CR1, USART_CR1_UE);

	//receive and transmit enable
	MODIFY_REG(USART1->CR1, USART_CR1_FIELDS, 0xC);

	//set baud rate
	WRITE_REG(USART1->BRR, 94U); //   ( 160,000,000Hz + Baud / 2 ) / Baud

	/* In asynchronous mode, the following bits must be kept cleared:
	  - LINEN and CLKEN bits in the USART_CR2 register,
	  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
	CLEAR_BIT(USART1->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
	CLEAR_BIT(USART1->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));

	//enable USUART
	SET_BIT(USART1->CR1, USART_CR1_UE);

	while (READ_BIT(USART1->ISR, USART_ISR_TEACK) != USART_ISR_TEACK)
	{}

	while (READ_BIT(USART1->ISR, USART_ISR_REACK) != USART_ISR_REACK)
	{}

}

void start_xfer(void){


}

int main(void)
{

	system_clk_init();
	GPIO_init();
	USART_init();
	TIM3_init();
	NVIC_init();
	SPI_init();
	DMA_init((uint8_t *)RxBuffer);
	CRC_init();

/*	while ((GPIOA->IDR & 0b10000) != 0b10000) {

	}*/
	TIM3->CCER = 0x11; //compare 1 output enable

	//Set xfer size
	MODIFY_REG(SPI1->CR2, SPI_CR2_TSIZE, Size);

	//Enable SPI interrupts
	WRITE_REG(SPI1->IER, (SPI_IER_EOTIE  |  SPI_IER_OVRIE | SPI_IER_UDRIE | SPI_IER_TIFREIE | SPI_IER_MODFIE));

	//Enable SPI1 peripheral
	SET_BIT(SPI1->CR1, SPI_CR1_SPE);

	//pause
	uint32_t count = 16000000;
	while (count > 0U) {
	asm("NOP");
	count--;
	}


	//Master transfer start
	SET_BIT(SPI1->CR1, SPI_CR1_CSTART);

	//NVIC_EnableIRQ(EXTI4_IRQn);




    /* Loop forever */
	for(;;);
}


void EXTI4_IRQHandler(void)
{

	//Clear EXTI4 interrupt
	EXTI->FPR1 = (0x10);



}


void SPI1_IRQHandler(void)
{






	//uint32_t rxbuf[10];
	//rxbuf[0] = SPI1->RXDR;

	/*uint8_t itsource = SPI1->SR;

	if ((itsource & SPI_IER_RXPIE) == SPI_IER_RXPIE) { //RXP set
		uint8_t readdata = SPI1->RXDR;
		RxBytesRemaining--;

		if (RxBytesRemaining == 0)
		{
		CLEAR_BIT(SPI1->IER, SPI_IER_RXPIE);
		}
		return;
	}

	if ((itsource & SPI_IER_EOTIE) == SPI_IER_EOTIE) { //EOT set

	//clear EOT and TXTF interrupt flags
	SET_BIT(SPI1->IFCR, SPI_IFCR_EOTC);
	SET_BIT(SPI1->IFCR, SPI_IFCR_TXTFC);

		//disable SPI interrupts
		WRITE_REG(SPI1->IER, 0x0);

		//Disable SPI1 peripheral
		//CLEAR_BIT(SPI1->CR1, SPI_CR1_SPE);

		//NVIC_EnableIRQ(EXTI4_IRQn);
	}*/
}

void GPDMA1_CH6_IRQHandler(void)
{
	if (READ_BIT(GPDMA1_Channel6->CSR, DMA_FLAG_TC) != DMA_FLAG_TC) {
		return;
	}

	//clear interrupt flags
	WRITE_REG(GPDMA1_Channel6->CFCR, (DMA_FLAG_TC | DMA_FLAG_HT));

	uint16_t count = 65532;
	uint8_t *pdata8bits = (uint8_t *)RxBuffer;

	while (count > 0U) {

		if (count % 4 == 0) {
			WRITE_REG(CRC->DR, (uint32_t)(*pdata8bits & 0xFFU) << 8*3 |\
					(uint32_t)(*(pdata8bits + 1) & 0xFFU) <<8*2 |\
					(uint32_t)(*(pdata8bits + 2) & 0xFFU) <<8 |\
					(uint32_t)(*(pdata8bits + 3) & 0xFFU));
			*pdata8bits = (uint8_t)READ_REG(CRC->DR);
		}

		while (READ_BIT(USART1->ISR, UART_FLAG_TXE) != UART_FLAG_TXE)
			{}

		WRITE_REG(USART1->TDR, (uint8_t)(*pdata8bits & 0xFFU));
		pdata8bits++;
		count--;
		}

	while (READ_BIT(USART1->ISR, UART_FLAG_TC) != UART_FLAG_TC)
	{}


	if ((SPI1->SR & SPI_IER_EOTIE) == SPI_IER_EOTIE) { //EOT set

		//clear EOT and TXTF interrupt flags
		SET_BIT(SPI1->IFCR, SPI_IFCR_EOTC);
		SET_BIT(SPI1->IFCR, SPI_IFCR_TXTFC);

	    SET_BIT(GPDMA1_Channel6->CCR, DMA_CCR_EN );

		//Master transfer start
		SET_BIT(SPI1->CR1, SPI_CR1_CSTART);
	}
}


void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
    /* USER CODE END W1_HardFault_IRQn 0 */
  }
}

void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
  {
  }
  /* USER CODE END NonMaskableInt_IRQn 1 */
}

void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    /* USER CODE END W1_BusFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    /* USER CODE END W1_UsageFault_IRQn 0 */
  }
}



